<?php

/* провряет строку на соответствие регулярному выражению.
Эта функция возвращает 1 в случае соответствия и 0 - если нет.
В случае ошибки эта функция вернет false.
В этом случае мы описали регулярное выражение, используя альтернативу и экранируя символ точки,
т.к. этот символ является мета-символом.
Заметим, что эта функция требует, чтоб регулярное выражение записывалось вместе с делимитерами.
В качестве делимитеров можно, например, использовать @.
*/
// этой функции можно указать третий аргумент $matches- массив, в который будут записаны найденные подстроки.

$str = 'Honda-id-138451.html';
$pattern = '@(Honda|Mazda)-id-[0-9]+\.html@';
var_dump(preg_match($pattern, $str, $matches)); // score! we got 1
print_r($matches);

/*аметим, что эта функция найдет лишь одно соответствие регулярному выражению.
Для того, чтобы найти все соответствия в строке используется preg_match_all ( $pattern, $string, [$matches] )*/

$str = 'Honda-id-138451.html, Mazda-id-999.html';
$pattern = '@(Honda|Mazda)-id-[0-9]+\.html@';
preg_match_all($pattern, $str, $matches);
print_r($matches);

/*preg_replace ( $pattern , $replacement , $string ) -
действует аналогично функции str_replace,
но поиск подстрок осуществляется по выражению, а не по простой строке. Например*/
$str = 'Honda-id-138451.html, Mazda-id-999.html';
$pattern = '@[0-9]+@';
echo preg_replace($pattern, 'N', $str); //Honda-id-N.html, Mazda-id-N.html
